<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Head Rotation</title>
    <style>
        #slider {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
    </style>
</head>
<body>
<!-- Slider for rotating the head -->
<input type="range" id="slider" min="-1" max="1" step="0.01" value="0">

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';

    // Create a WebGL renderer with anti-aliasing enabled
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement); // Attach renderer to the DOM

    var headBone;
    var sliderValue = 0; // Initialize slider value for head rotation

    // Event listener for Flutter WebView integration readiness
    window.addEventListener("flutterInAppWebViewPlatformReady", function(event) {
        isFlutterInAppWebViewReady = true;
    });

    // Event listener for external head movement commands
    window.addEventListener("moveHead", function(event) {
        rotateHead(...event.detail);
    }, false);

    // Set background color for the scene
    renderer.setClearColor(0xFEFEFE);
    const scene = new THREE.Scene();

    // Create a perspective camera
    const camera = new THREE.PerspectiveCamera(
        30,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );

    // Enable orbit controls for camera movement
    const orbit = new OrbitControls(camera, renderer.domElement);

    // Initialize quaternion variables for sensor-based head rotation
    var prevSensorQuaternion = new THREE.Quaternion(0, 0, 0, 1);
    var sensorDelta = new THREE.Quaternion(0, 0, 0, 1);

    /**
     * Function to rotate the head using quaternion values from sensors
     * @param {number} w - Quaternion W component
     * @param {number} x - Quaternion X component
     * @param {number} y - Quaternion Y component
     * @param {number} z - Quaternion Z component
     */
    function rotateHead(w, x, y, z) {
        var sensorQuaternion = new THREE.Quaternion(y, x, z, w);
        sensorQuaternion.normalize(); // Normalize to ensure valid rotation

        // Compute the delta rotation based on previous sensor reading
        sensorDelta.multiplyQuaternions(sensorDelta, prevSensorQuaternion.clone().invert().multiply(sensorQuaternion));
        headBone.setRotationFromQuaternion(sensorDelta);
        prevSensorQuaternion = sensorQuaternion; // Update previous quaternion
    }

    /**
     * Function to rotate the head using slider input
     * @param {number} value - Rotation value from the slider (in radians)
     */
    function rotateHeadWithSlider(value) {
        var quaternion = new THREE.Quaternion();
        quaternion.setFromEuler(new THREE.Euler(0, value, 0)); // Rotate around Y-axis
        headBone.setRotationFromQuaternion(quaternion);
    }

    // Event listener for slider input changes
    // Adjusts head rotation based on slider value
    document.getElementById('slider').addEventListener('input', function(event) {
        sliderValue = parseFloat(event.target.value);
        rotateHeadWithSlider(sliderValue);
    });

    // Load the FBX model
    const loader = new FBXLoader();
    loader.load('assets/Ch36_nonPBR.fbx', function (model) {
        model.scale.set(.01, .01, .01); // Scale model to fit scene

        const skeleton = new THREE.SkeletonHelper(model);
        skeleton.visible = true; // Display skeleton for debugging
        console.log(model);

        // Get reference to the head bone for rotation
        headBone = model.getObjectByName("mixamorig1Head");

        // Get world position of the head bone
        const headBoneWorldPosition = new THREE.Vector3();
        const headPos = headBone.getWorldPosition(headBoneWorldPosition);

        // Create a visual reference ring at the head's position
        var circleGeometry = new THREE.RingGeometry(1, 1.005, 32, 1, 0, Math.PI * 2);
        var circleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        var circleMesh = new THREE.Mesh(circleGeometry, circleMaterial);
        circleMesh.position.set(headPos.x, headPos.y, headPos.z);
        circleMesh.rotation.x = Math.PI / 2;

        // Position the camera relative to the head
        const distance = 2;
        const offset = headBoneWorldPosition.clone().add(new THREE.Vector3(0, 0, distance));
        camera.position.copy(offset);
        orbit.target.copy(headBoneWorldPosition);

        // Restrict camera movement angles
        orbit.minPolarAngle = Math.PI / 4;
        orbit.maxPolarAngle = Math.PI / 2;
        orbit.minAzimuthAngle = -Math.PI / 4;
        orbit.maxAzimuthAngle = Math.PI / 4;
        orbit.update();

        // Add objects to scene
        scene.add(skeleton);
        scene.add(model);
    }, undefined, function (error) {
        console.error(error); // Handle model loading errors
    });

    // Add ambient lighting to the scene
    const ambientLight = new THREE.AmbientLight(0xFFFFFF);
    ambientLight.intensity = 2;
    scene.add(ambientLight);

    // Add a grid helper for scene reference
    const gridHelper = new THREE.GridHelper(12, 12);
    scene.add(gridHelper);

    // Add an axes helper for orientation reference
    const axesHelper = new THREE.AxesHelper(4);
    scene.add(axesHelper);

    // Animation loop to render the scene
    function animate() {
        renderer.render(scene, camera);
    }

    // Set the renderer to continuously update the animation
    renderer.setAnimationLoop(animate);

    // Adjust camera and renderer size on window resize
    window.addEventListener('resize', function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
